# cs334 HW7

# Instructions for starting up the interface

Clone the repository and cd into the directory. Navigate to lang/funny_visual_interface_v2 and cd into the version that works for your operating system (linux or windows for the time being). Don't move anything, as the interface will not work if placed in a different directory. Open a terminal in that directory and run the file named funny_visual_interface_v2.

# Instructions for using the interface

The interface is separated into two parts: the _Toolbox_ and the _Workshop_.

The _Toolbox_ is where the available functions are shown. To find the desired function the user can scroll until it is shown. To use a function in a program all the user has to do is click it in the _Toolbox_ and it will appear in the _Workshop_ to be used in any of the ways that will be described later in this document. A function that was saved from the _Workshop_ in the _Toolbox_ can be removed by right clicking it. The built-in functions that appear in the _Toolbox_ when the interface is launched cannot be removed in this manner. The pre-built functions are the following: _id_, _plus_, _minus_, _times_, _div_, _mod_, _if_, _le_, _gr_, _eq_, _pair_, _fst_, _snd_, _toInteger_, _toReal_, _self_. All of these, except for _self_ are the core functions that are implemented in F\# and constitute the basis for all other functions. _self_ is a special function used in recursive definitions. When defining a recursive function, _self_ represents the function as a whole and can be used to implement the recursive calls. The following functions are also available by default and cannot be deleted, but they are not implemented in F\#, they are implemented in the Funny Language itself. They are _min_, _max_, _leq_, _geq_, _or_, _and_, _not_, _length_, _elemAt_, _append_, _range_, _repeat_, _reverse_, _zip_.

The _Workshop_ is where the programming happens. There are 3 buttons on the top part of the _Workshop_, labeled S, R, V (standing for Save, Run and Value respectively). Clicking S will prompt for a name to be typed and, if the function in the _Workshop_ is a valid function definition, it will save it in the _Toolbox_ for later use. Clicking R will attempt to run the program in the _Workshop_. If the program is valid and produces an output, the output will be displayed over the buttons. Clicking V will prompt for typing and will insert the typed value in the _Workspace_ for later use. Any value that is not "True", "False", "Nil", an integer, or a floating point number will be considered the name of an argument. Inserting an argument has an important effect on the _Workshop_ which will be discussed shortly.   

Programming in the _Workshop_ is fairly straightforward. All the user has to do is connect inputs to functions. Functions and Values are inserted into the _Workshop_ as described above. Clicking on any object in the _Workshop_ (a function or a value) will make it selected (drawn in gray) and when a second object is clicked, the first selected object will be connected as an input to the second clicked object. If the two are already connected they will be disconnected instead, and if the same object is clicked twice, it will be removed from the _Workshop_. Note that arguments are passed to functions in the order in which they were connected. It is also important to note that only functions take inputs, values do not, but both functions and values can be passed as inputs to other functions. All valid programs end in a single function whose output is passed to nothing, and is considered the output of the entire program. There cannot be many of those, only one.

To make a function definition, all that is needed is for at least one argument to be present in the _Workshop_. If at least one argument is present, the function cannot be run, as it is not an application, but a definition. A definition can be saved and used later, passing concrete values in the place of arguments. The order in which the function will accept the arguments depends on their layout on the screen when the function is saved. The leftmost argument will be what the function expects to receive first, the rightmost is what it expects to receive last and in the same fashion it will treat all the argument in between.   

The _Workshop_ is also scrollable, to allow for the creation of longer programs. However, if a program is getting too long it can always be broken up in smaller, helper functions that will be combined to form the final program. This does not only make writing the program easier in practical issues (less scrolling and less clutter on the screen) but it also allows for testing the individual parts of the program, as well as reusing them in case they are needed.

Writing a function appliation is equally simple. Anything that does not contain an argument is a function application and, if it is valid, it can be run. When a function is run, its output is displayed right under the word "Workshop" in the interface.

So, for example, if I wanted to make a function ```plusOne```, this is the process that I would need to follow:  
Add the function ```plus``` from the _Toolbox_ and move it to a comfortable position in my workshop. Add the value ```1``` using the button on the upper right corner, move it to a comfortable position and then successively click on the ```1``` and the ```plus``` function. This will add ```1``` as the first argument passed to the function. Then I would add the value ```n``` from using the button, move it to a comfortable position and successively click on ```n``` and the function. Note that the order of the arguments is reflected on the positions in which the lines from the arguments to the function connect: the line connecting farther to the left corresponds to the first argument, the next one to the second etc. Now I can hit the save button and give the name ```plusOne```. Now ```plusOne``` appears in the _Toolbox_ to be used as any other function. As a test, I can now pull it into the _Workshop_, give it the value ```1``` as an argument and hit the run button. The number 2 should appear in the interface.

# Lab Feedback

## Ready for Feeback?
 - [ ] Not completed, development is still in progress
 - [x] Completed, this lab is ready for review.
